---
title: PHP常见面试题
date: 2019-08-06 21:17:22
tags:
    - PHP
---
收集了一些常见的面试题
<!-- more -->

#### 请选择以下代码运行的结果
```php
if ('1e3' == '1000') {
    echo 'LOL';
}

/*输出*/
LOL
/*解析*/
`1e3` 是 科学计数法 实数的指数形式 为1乘以10的三次方，故‘1e3’=='1000'是成立的，输出echo `LOL`
```

#### 请选出以下代码运行的结果
```php
$a = "aabbzz";
$a++;
echo $a;

/*输出*/
aabcaa
/*解析*/
字符串字母相加其实就是在末尾字母加一
如：$a = "a"; $a++;答应结果就是 b,$a='aa';结果就是ab 故$a = "aabb";打印结果就是 aabc ,如$a = "aabbz";结果就是 aabca
因为Z是末尾字母故加一变为a,向前一位进一,b就变为c,故结果为C
```

#### 引用易错点
```php
$data = ['a','b','c'];
foreach($data as $k=>$v){
    $v = &$data[$k];
}

/*输出*/
$data = ['b','c','c'];
/*解析*/
这里有个考点要记得就是&是引用；修改引用变量的值，那么空间的值也会改变
第一次循环 得到$v=&$data[0]=>'a'

第二次循环$v=&$data[1]=>'b'($v=$data[0]),可见第一次引用的$data[0]的值已经被改变，所以此时的$data[0]=b,此时$v引用的$data[1]

进入第三次循环 此时$v又变为$v=&$data[2]=>'c'($v=$data[1]),$v又一次改变，引用的$data[1]的值也被改变为C

所以此时的$data[1]=c,这样循环结束 $data[0]=>'b'， $data[1]=>'c'， $data[2]=>'c'
```

```php
$data = ['a','b','c'];

foreach ($data as &$v) {
}

foreach ($data as $v) {
}

unset($v);

var_dump($data);

/*输出*/
$data = ['a','b','b'];
/*解析*/

/* 第一次遍历 */
$v = &$data[0];
$v = &$data[1];
$v = &$data[2];

// 第一次遍历完成后, 这个时候 $v = &$data[2]


/* 第二轮遍历 */
// 因为$v等价于$data[2],相当于$data[2] = $data[0],把$data[2]赋值为a(即$data[0]); 此时数组array = ['a','b','a'];
$v = $data[0];

// 因为$v等价于$data[2],相当于$data[2] = $data[1],把$data[2]赋值为b(即$data[1]); 此时数组array = ['a','b','b'];
$v = $data[1];

// 因为$v等价于$data[2],相当于$data[2] = $data[2],即赋值为其本身,而此时已经被上一次赋值为b; 此时数组array = ['a','b','b'];
$v = $data[2];

// 第二次遍历完后, array = ['a','b','b']

unset($v); // unset($v)释放掉临时的引用
```
#### 写出一下程序的输出结果
```php
$a= 0.1;
$b = 0.7;

if ($a+$b ==0.8){
    echo true;
} else {
    echo false;
}

/*输出*/
空
/*解析*/
这里的考点有两个：
1，echo false和true的值
2、浮点类型不能用于精确计算

首先浮点类型的数据不能用于计算，他会将浮点类型转为二进制，所以有一定的损耗，故它无限接近于0.8，也就是0.79999999...，所以echo 应该是个false；echo false；结果是空；echo true；结果是1
```

#### 用PHP写出显示客户端的IP和服务端的IP
```php
echo $_SERVER[‘REMOTE_ADDR’]; //客户端IP

echo gethostbyname("www.baidu.com"); //服务端
```

#### 运算符的优先级
```php
$a = 0;
$b = 0;
if ($a = 3 > 0 || $b = 3 > 0) {
    $a++;
    $b++;
}
echo $a,$b;

/*输出*/
1,1
/*解析*/
此题考查的是运算符的优先级问题，首先在此题中比较运算符>逻辑运算符>赋值
所以1，先看 3>0为true,2，因为是||运算所以后面的$b=3>0 形成短路作用，这时的$a=true,$b=0;

故$a++;为1；$b++;为1这里解释下布尔类型运算不影响布尔类型结果；但是$b=0;$b++;就改变为1， echo true；结果为1
```

#### PHP中如何优化多个if...esleif语句的情况
```php
/*解析*/
首先尽可能将表达式可能性越大的越往前面放，其次如果我们判断的内容比较复杂且 判断的值只是字符串，整型，浮点 那么就可以用switch...case来代替
```

#### 函数以及变量引用综合例子
```php
val1= 5;
$val2 = 10;
function foo(&$my_val){
    global $val1;
    $val1+=2;//7
    $val2 =4;//4
    $my_val +=3;//8
    return $val2;//4
}
$my_val = 5;
echo foo($my_val)."\n";//4
echo $my_val;//8
echo $val1."\n".$val2;//7   10
$bar = 'foo';
$my_val =10;
echo $bar($my_val)."\n";//4s
```

#### 用PHP方式对目录进行遍历
```php
$dir = './test';

function loopDir($dir){
    $handle = opendir($dir);
    while(false !== ($file =readdir($handle))){
        if($file != '.' && $file != '..') {
            echo $file."<br>";
            if(filetype($dir.'/'.$file) == 'dir') {
                loopDir($dir.'/'.$file);
            }
        }
    }
}

loopDir($dir);
```

#### 请简单叙述 CGI fastCGI h和  PHP-FPM的区别
> CGI 代表为了联系PHP 和websevae 的一个桥梁
> fastCGI 是CGI的改良版
> PHP-FPM  进程管理器

#### 排序
1. 冒泡排序
```php
function maopao($arr) {
    $len = count($arr);
    $n = count($arr) - 1;

    for($i = 0; $i < $len; $i++) {
        for($j = 0; $j < $n; $j++) {

            if($arr[$j] < $arr[$j+1]) {
                $temp = $arr[$j+1];
                $arr[$j+1] = $arr[$j];
                $arr[$j] = $temp;
            }

        }
    }
    return $arr;
}
```
2. 快速排序
```php
function quick_sort($array) {

    if (count($array) <= 1) return $array;

    $key = $array[0];

    $left_arr = array();

    $right_arr = array();

    for ($i = 1; $i < count($array); $i++) {

        if ($array[$i] <= $key)

            $left_arr[] = $array[$i];

        else

            $right_arr[] = $array[$i];

    }

    $left_arr = quick_sort($left_arr);

    $right_arr = quick_sort($right_arr);

    return array_merge($left_arr, array($key), $right_arr);

}
```

#### 请说明 PHP 中传值与传引用的区别，什么时候传值什么时候传引用?
```php
按值传递：函数范围内对值的任何改变在函数外部都会被忽略

按引用传递：函数范围内对值的任何改变在函数外部也能反映出这些修改

优缺点：按值传递时，php必须复制值。特别是对于大型的字符串和对象来说，这将会是一个代价很大的操作。

按引用传递则不需要复制值，对于性能提高很有好处。
```

#### MySQL数据库中的字段类型varchar和char的主要区别是什么?
```php
char和varchar最大的不同就是一个是固定长度,一个是可变长度.由于是可变长度,因此存储的是实际字符串再加上一个记录字符串长度的字节。如果分配给char或varchar列的值超过 列的最大长度,则对值进行裁剪.

varchar(M)和char(M),M都表示字符数.varchar的最大长度为65535个字节,不同的编码所对应的最大可存储的字符数不同.char最多可以存放255个字符,不同的编码最大可用字节数不同
```

#### 对于大流量的网站，采用什么样的方法来解决访问量问题？
1. 确认服务器硬件是否足够支持当前的流量
2. 优化数据库访问
3. 禁止外部的盗链
4. 控制大文件的下载
5. 使用不同主机分流主要流量(分布式部署)
6. 使用流量分析统计软件
7. 尽量使用静态页，缓存

- 什么是面向对象？主要特征是什么？
> 面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。

- SESSION 与 COOKIE的区别是什么？

```
SESSION存储在服务器端，COOKIE保存在客户端。
Session比较安全，cookie用某些手段可以修改，不安全。
Session依赖于cookie进行传递。禁用cookie后，session还可以使用，在存储session的文件中，生成sessionID，通过get传参的方式将sessionID传到要实现session共享的页面，读取sessionID,从而从session中获取数据。
```

#### 对缓存技术的了解
1. 缓存技术是将动态内容缓存到文件中，在一定时间内访问动态页面直接调用缓存文件，而不必重新访问数据库。
2. 使用memcache,redis可以做缓存

- 表单中get和post提交方式的区别
> get是显式的，数据从url中可以看到，传输的数据量小，安全性低； post是隐式的，传送的数据量较大，安全性较高

#### 优化mysql数据库的方法
1. 数据表中的数据类型的优化  如选择合适的字段，选择效率快速的字段
2. 索引优化
3. SQL语句的优化z
    - 优化查询过程中的数据访问如使用limit、使用返回列不用*
    - 优化长难句的查询语句 变复杂为简单、切分查询、分解关联查询
    - 优化特定类型的查询语句如优化count()、优化关联查询、优化子查询、优化Group by、优化limit
4. 存储引擎的优化
    - 尽量使用InnoDB存储引擎，因为它支持事务、外键、使用独立表空间、使用的是行级锁
5. 数据表结构的设计优化
    - 分区操作 如通过特定的策略对数据进行物理拆分、对用户透明的、partition by
    - 分库分表  如水平拆分（以行级进行拆分）、垂直拆分（列及拆分）
6. 数据架构的优化
    - 主从复制
    - 读写分离
    - 双主热备
    - 负载均衡　　通过LVS的三种模式实现的、Mycat数据库中间件实现的

- 语句include和require的区别是什么？
> require是无条件包含，也就是如果一个流程里加入require，无论条件成立与否都会先执行require，当文件不存在或者无法打开的时候，会提示错误，并且会终止程序执行
> include有返回值，而require没有(可能因为如此require的速度比include快)，如果被包含的文件不存在的化，那么会提示一个错误，但是程序会继续执行下去

#### redis和memcacahe、mongoDB的区别？

> 都是非关系型数据库，性能都非常高，但是mongoDB和memcache、redis是不同的两种类型。后两者主要用于数据的缓存，前者主要用在查询和储存大数据方面，是最接近数据库的文档型的非关系数据库。

> 从数据存储位置上来分，memcache的数据存在内存中，而redis既可以存储在内存中，也可以存储的到磁盘中，达到持久化存储的功能，memcache一旦断电，数据全部丢失，redis可以利用快照和AOF把数据存到磁盘中，当恢复时又从磁盘中读取到内存中，当物理内存使用完毕后，可以把数据写入到磁盘中。

> 从存储数据的类型上来分，memcache和redis存储的方式都是键值对，只不过redis值的类型比较丰富，有string(字符串),hash(哈希)，list(列表),set(集合)zset(有序集合)，而memcache主要存储的是字符串。

#### PHP的基本变量类型
1. 四种标量类型：boolean （布尔型）、integer （整型）、float （浮点型, 也称作 double)、string （字符串）
2. 两种复合类型：array （数组）、object （对象）
3. 最后是两种特殊类型：resource（资源）、NULL（NULL）

#### 静态化如何实现的？伪静态如何实现？
1. 静态化指的是页面静态化，也即生成实实在在的静态文件，也即不需要查询数据库就可以直接从文件中获取数据，指的是真静态。
    1. 实现方式主要有两种：
    - 一种是我们在添加信息入库的时候就生成的静态文件，也称为模板替换技术。
    - 一种是用户在访问我们的页面时先判断是否有对应的缓存文件存在，如果存在就读缓存，不存在就读数据库，同时生成缓存文件。
2. 伪静态不是真正意义上的静态化，之所以使用伪静态，主要是为了SEO推广，搜索引擎对动态的文件获取难度大，不利于网站的推广。实习原理是基于Apache或Nginx的rewrite机智
    1. 主要有两种方式：
    - 一种是直接在配置虚拟机的位置配置伪静态，这个每次修改完成后需要重启web服务器。
    - 另一种采用分布式的，可以在网站的根目录上创建.htaccess的文件，在里面配置相应的重写规则来实现伪静态，这种每次重写时不需要重启web服务器，且结构上比较清晰。

#### 如何处理负载，高并发
1. HTML静态化
> 效率最高、消耗最小的就是纯静态化的html页面，所以我们尽可能使我们的 网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。

2. 图片服务器分离
> 把图片单独存储，尽量减少图片等大流量的开销，可以放在一些相关的平台上，如七牛等

3. 数据库集群和库表散列及缓存
> 数据库的并发连接为100，一台数据库远远不够，可以从读写分离、主从复制，数据库集群方面来着手。另外尽量减少数据库的访问，可以使用缓存数据库如memcache、redis。

4. 镜像
> 尽量减少下载，可以把不同的请求分发到多个镜像端

5. 负载均衡
> Apache的最大并发连接为1500，只能增加服务器，可以从硬件上着手，如F5服务器。当然硬件的成本比较高，我们往往从软件方面着手。

#### Mysql的读写分离?
> 读写分离的实现原理就是在执行SQL语句的时候，判断到底是读操作还是写操作，把读的操作转向到读服务器上（从服务器，一般是多台），写的操作转到写的服务器上（主服务器，一般是一台，视数据量来看）。

#### 说一下单引号双引号？
> 单引号内部的变量不会执行， 双引号会执行
> 单引号解析速度比双引号快。
> 单引号只能解析部分特殊字符，双引号可以解析所有特殊字符。

#### PHP7的新特性？重点
- 标量类型声明：PHP 7 中的函数的形参类型声明可以是标量了。在 PHP 5 中只能是类名、接口、array 或者 callable (PHP 5.4，即可以是函数，包括匿名函数)，现在也可以使用 string、int、float和 bool 了。

- 返回值类型声明：增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。

- NULL 合并运算符：由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。

- use 加强：从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了

- 匿名类：现在支持通过new class 来实例化一个匿名类

#### PHP 数组排序

- sort() - 以升序对数组排序

- rsort() - 以降序对数组排序

- asort() - 根据值，以升序对关联数组进行排序

- ksort() - 根据键，以升序对关联数组进行排序

- arsort() - 根据值，以降序对关联数组进行排序

- krsort() - 根据键，以降序对关联数组进行排序

#### PHP支持多继承吗？
> 不支持。PHP中只允许单继承，父类可以被一个子类用关键字“extends”继承。

#### PHP如何实现多继承吗？

可以使用 interface 或 trait 实现 。

1. 使用 interface 声明类不能被实例化，并且属性必须是常量，方法不能有方法体　

2. trait 声明的类不能被实例化，由use引入，会覆盖父类的相同属性及方法，如果有多个use,那么按顺序下面的覆盖最上面的相同的属性及方法

#### 优化MYSQL数据库的方法

- 选择最有效率的表名顺序

- WHERE子句中的连接顺序

- SELECT子句中避免使用‘*’

- 用Where子句替换HAVING子句

- 通过内部函数提高SQL效率

- 避免在索引列上使用计算。

- 提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。

- 选取最适用的字段属性,应该尽量把字段设置为NOT NULL

- 使用连接（JOIN）来代替子查询(Sub-Queries)

- 使用联合(UNION)来代替手动创建的临时表

- 尽量少使用 LIKE 关键字和通配符

- 使用事务和外键

#### MySQL主从备份的原理？
> mysql支持单向、异步复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。

#### error_reporting() 的作用？
> 设置 PHP 的报错级别并返回当前级别。

#### 如何修改session的生存时间
1. 在php.ini 中设置 session.gc_maxlifetime = 1440 //默认时间
2. 代码实现
```php
$lifeTime = 24 * 3600; // 保存一天

session_set_cookie_params($lifeTime);

session_start();
```

#### 常见的 PHP 安全性攻击
1. SQL注入：用户利用在表单字段输入SQL语句的方式来影响正常的SQL执行。
    防止：
    - 使用mysql_real_escape_string()过滤数据
    - 手动检查每一数据是否为正确的数据类型
    - 使用预处理语句并绑定变量
    - 参数化SQL：是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数 (Parameter) 来给值，用@或？来表示参数。

2. XSS攻击 ：跨站点脚本攻击，由用户输入一些数据到你的网站，其中包括客户端脚本(通常JavaScript)。如果你没有过滤就输出数据到另一个web页面，这个脚本将被执行。
    > 防止：为了防止XSS攻击，使用PHP的htmlentities()函数过滤再输出到浏览器。

3. CSRF：跨站点请求伪造，是指一个页面发出的请求，看起来就像是网站的信任用户，但是是伪造的
    > 防止：一般来说，确保用户来自你的表单，并且匹配每一个你发送出去的表单。有两点一定要记住：
    > 对用户会话采用适当的安全措施，例如:给每一个会话更新id和用户使用SSL。
    > 生成另一个一次性的令牌并将其嵌入表单，保存在会话中(一个会话变量)，在提交时检查它。 如laravel中的 _token

4. 代码注入：代码注入是利用计算机漏洞通过处理无效数据造成的。问题出在，当你不小心执行任意代码，通常通过文件包含。写得很糟糕的代码可以允许一个远程文件包含并执行。如许多PHP函数，如require可以包含URL或文件名。
    > 防止代码注入
    > 过滤用户输入
    > 在php.ini中设置禁用allow_url_fopen和allow_url_include。这将禁用require/include/fopen的远程文件

#### __FILE__表示什么意思？
> 文件的完整路径和文件名。如果用在包含文件中，则返回包含文件名。自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径，而在此之前的版本有时会包含一个相对路径。

#### PHP如何实现页面跳转
1. 方法一：php函数跳转，缺点，header头之前不能有输出，跳转后的程序继续执行，可用exit中断执行后面的程序。
    - header("Location:网址");//直接跳转
    - header("refresh:3;url=http://www.jsdaima.com");//三秒后跳转
2. 方法二：利用meta
    - `<meta http-equiv="refresh" content="3;url='helloworld.php'">`

#### $str是一段html文本，使用正则表达式去除其中的所有js脚本

```
$pattern = '/<script.*>\.+<\/script>/';

preg_replace($pattern, '', $str);
```

#### mvc是什么?相互间有什么关系?
> mvc是一种开发模式,主要分为三部分:m(model),也就是模型,负责数据的操作;v(view),也就是视图,负责前后台的显示;c(controller),也就是控制器,负责业务逻辑

> 客户端请求项目的控制器,如果执行过程中需要用到数据,控制器就会到模型中获取数据,再将获取到的数据通过视图显示出来

#### oop是什么?
> oop是面向对象编程,面向对象编程是一种计算机编程架构,OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。
- **封装性**：也称为信息隐藏，就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系，或者说只公开了一些供开发人员使用的方法。于是开发人员只 需要关注这个类如何使用，而不用去关心其具体的实现过程，这样就能实现MVC分工合作，也能有效避免程序间相互依赖，实现代码模块间松藕合。
- 继承性：就是子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性。PHP只支持单继承，也就是说一个子类只能有一个父类。
- 多态性：子类继承了来自父级类中的属性和方法，并对其中部分方法进行重写。于是多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果，这种技术就是多态性。多态性增强了软件的灵活性。

1. 易维护
> 采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的。

2. 质量高
> 在设计时，可重用现有的，在以前的项目的领域中已被测试过的类使系统满足业务需求并具有较高的质量。

3. 效率高
> 在软件开发时，根据设计的需要对现实世界的事物进行抽象，产生类。使用这样的方法解决问题，接近于日常生活和自然的思考方式，势必提高软件开发的效率和质量。

4. 易扩展
> 由于继承、封装、多态的特性，自然设计出高内聚、低耦合的系统结构，使得系统更灵活、更容易扩展，而且成本较低。

#### smarty是什么,有什么作用?
> smarty是用php写出来的模板引擎,也是目前业界最著名的php模板引擎之一

> 它分离了逻辑代码和外在的显示,提供了一种易于管理和使用的方法,用来将混杂的php逻辑代码与html代码进行分离，我们公司使用的是TP框架,已经封装好了smarty模板,所以没有单独使用过。

#### thinkphp的特性有哪些?
1. 多表查询非常方便,在model中几句代码就可以完成对多表的关联操作
2. 融合了smarty模板,使前后台分离
3. 支持多种缓存技术,尤其对memcache技术支持非常好
4. 命名规范,模型,视图,控制器严格遵循命名规则,通过命名一一对应
5. 支持多种url模式
6. 内置ajax返回方法,包括xml,json,html等
7. 支持应用扩展,类库扩展,驱动扩展等

#### 请介绍一下laravel框架?
> laravel框架的设计思想比较先进,非常适合应用各种开发模式,作为一个框架,它为你准备好了一切,composer是php的未来,没有composer,php肯定要走向没落

> laravel框架最大的特点和优秀之处就是集合了php比较新的特点,以及各种各样的设计模式,Ioc模式,依赖注入等

#### 请简述一下数据库的优化?
> 数据库的优化可以从四个方面来优化:
> 1. 从结构层: web服务器采用负载均衡服务器,mysql服务器采用主从复制,读写分离
> 2. 从储存层: 采用合适的存储引擎,采用三范式
> 3. 从设计层: 采用分区分表,索引,表的字段采用合适的字段属性,适当的采用逆范式,开启mysql缓存
> 4. sql语句层:结果一样的情况下,采用效率高,速度快节省资源的sql语句执行

#### 怎么保证促销商品不会超卖?

> 这个问题是我们当时开发时遇到的一个难点，超卖的原因主要是下的订单的数目和我们要促销的商品的数目不一致导致的，每次总是订单的数比我们的促销商品的数目要多，当时我们的小组讨论了好久，给出了好几个方案来实现：

1. 第一种方案：在每次下订单前我们判断促销商品的数量够不够，不够不允许下订单，更改库存量时加上一个条件，只更改商品库存大于0的商品的库存，当时我们使用ab进行压力测试，当并发超过500，访问量超过2000时，还是会出现超卖现象。所以被我们否定了。

2. 第二种方案：使用mysql的事务加排他锁来解决，首先我们选择数据库的存储引擎为innoDB，使用的是排他锁实现的，刚开始的时候我们测试了下共享锁，发现还是会出现超卖的现象。有个问题是，当我们进行高并发测试时，对数据库的性能影响很大，导致数据库的压力很大，最终也被我们否定了。

3. 第三种方案：使用文件锁实现。当用户抢到一件促销商品后先触发文件锁，防止其他用户进入，该用户抢到促销品后再解开文件锁，放其他用户进行操作。这样可以解决超卖的问题，但是会导致文件得I/O开销很大。

4. 最后我们使用了redis的队列来实现。将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖。这个操作起来很方便，而且效率极高，最终我们采取这种方式来实现

#### 商城秒杀的实现?

> 抢购、秒杀是如今很常见的一个应用场景，主要需要解决的问题有两个：
> 1. 高并发对数据库产生的压力
> 2. 竞争状态下如何解决库存的正确减少（"超卖"问题）
- 对于第一个问题，已经很容易想到用缓存来处理抢购，避免直接操作数据库，例如使用Redis。
- 第二个问题，我们可以使用redis队列来完成，把要秒杀的商品放入到队列中，因为pop操作是原子的，即使有很多用户同时到达，也是依次执行，文件锁和事务在高并发下性能下降很快，当然还要考虑其他方面的东西，比如抢购页面做成静态的，通过ajax调用接口，其中也可能会出现一个用户抢多次的情况，这时候需要再加上一个排队队列和抢购结果队列及库存队列。高并发情况下，将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在，则已抢购，否则未抢购，库存减1，写数据库，将用户入结果队列。

#### 购物车的原理?

> 购物车相当于现实中超市的购物车，不同的是一个是实体车，一个是虚拟车而已。用户可以在购物网站的不同页面之间跳转，以选购自己喜爱的商品，点击购买时，该商品就自动保存到你的购物车中，重复选购后，最后将选中的所有商品放在购物车中统一到付款台结账，这也是尽量让客户体验到现实生活中购物的感觉。服务器通过追踪每个用户的行动，以保证在结账时每件商品都物有其主。

**主要涉及以下几点:**
1. 把商品添加到购物车，即订购
2. 删除购物车中已定购的商品
3. 修改购物车中某一本图书的订购数量
4. 清空购物车
5. 显示购物车中商品清单及数量、价格
>> 实现购物车的关键在于服务器识别每一个用户并维持与他们的联系。但是HTTP协议是一种“无状态(Stateless)”的协议，因而服务器不能记住是谁在购买商品，当把商品加入购物车时，服务器也不知道购物车里原先有些什么，使得用户在不同页面间跳转时购物车无法“随身携带”，这都给购物车的实现造成了一定的困难。
目前购物车的实现主要是通过cookie、session或结合数据库的方式。

#### 什么事面向对象？主要特征是什么？
> 面向对象是程序的一种设计方式，它利于提高程序的重用性，使程序结构更加清晰。主要特征：封装、继承、多态。

#### SESSION 与 COOKIE的区别是什么，请从协议，产生的原因与作用说明?
- http无状态协议，不能区分用户是否是从同一个网站上来的，同一个用户请求不同的页面不能看做是同一个用户。
- SESSION存储在服务器端，COOKIE保存在客户端。Session比较安全，cookie用某些手段可以修改，不安全。Session依赖于cookie进行传递。
- 禁用cookie后，session不能正常使用。Session的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。Session保存在服务器端的文件或数据库中，默认保存在文件中，文件路径由php配置文件的session.save_path指定。Session文件是公有的。

#### HTTP 状态中302、403、 500代码含义？
> 一二三四五原则:（即一：消息系列；二：成功系列； 三：重定向系列；四：请求错误系列；五：服务器端错误系列。）
- 302:临时转移成功，请求的内容已转移到新位置
- 403:禁止访问
- 500:服务器内部错误
- 401：代表未授权。

#### 请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别？
- Int 整数
- char 定长字符
- Varchar 变长字符
- Datetime 日期时间型
- Text 文本型

**Varchar与char的区别**
- char是固定长度的字符类型，分配多少空间，就占用多长空间。
- Varchar是可变长度的字符类型，内容有多大就占用多大的空间，能有效节省空间。
> 由于varchar类型是可变的，所以在数据长度改变的时，服务器要进行额外的操作，所以效率比char类型低。

#### MyISAM和 InnoDB 的基本区别？索引结构如何实现？
- MyISAM类型不支持事务，表锁，易产生碎片，要经常优化，读写速度较快，适合用于频繁查询的应用；
- InnoDB类型支持事务，行锁，有崩溃恢复能力，读写速度比MyISAM慢，适合于插入和更新操作比较多的应用，空间占用大，不支持全文索引等。

> 创建索引：alert table tablename add index 索引名 (`字段名`)

#### isset() 和 empty() 区别
1. PHP的isset()函数 一般用来检测变量是否设置
> 格式：bool isset ( mixed var [, mixed var [, ...]] )

> 功能：检测变量是否设置

> 返回值：
> 若变量不存在则返回 FALSE
若变量存在且其值为NULL，也返回 FALSE
若变量存在且值不为NULL，则返回 TURE
同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE
版本：PHP 3, PHP 4, PHP 5
更多说明：
使用 unset() 释放变量之后，它将不再是 isset()。
PHP函数isset()只能用于变量，传递任何其它参数都将造成解析错误。
检测常量是否已设置可使用 defined() 函数。

2. PHP的empty()函数 判断值为否为空

> 格式：bool empty ( mixed var )

> 功能：检查一个变量是否为空

> 返回值：
> 若变量不存在则返回 TRUE
若变量存在且其值为""、0、"0"、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 TURE
> 若变量存在且值不为""、0、"0"、NULL、、FALSE、array()、var $var; 以及没有任何属性的对象，则返回 FALSE
版本：PHP 3, PHP 4, PHP 5
> 更多说明：
empty()的返回值=!(boolean) var，但不会因为变量未定义而产生警告信息。参见转换为布尔值获取更多信息。
empty() 只能用于变量，传递任何其它参数都将造成Paser error而终止运行。
检测常量是否已设置可使用 defined() 函数。

#### AJAX的优势是什么？
> ajax是异步传输技术，可以通过javascript实现，也可以通过JQuery框架实现，实现局部刷新，减轻了服务器的压力，也提高了用户体验。

#### 在程序的开发中，如何提高程序的运行效率？
- 优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询；
- 数据表中创建索引；
- 对程序中经常用到的数据生成缓存。

#### 对于大流量的网站,您采用什么样的方法来解决访问量问题?
- 有效使用缓存，增加缓存命中率
- 使用负载均衡
- 对静态文件使用cdn进行存储和加速
- 想法减少数据库的使用
- 查看出现统计的瓶颈在哪里
- 反向代理

#### foo()和@foo()之间有什么区别?
> @代表所有warning忽略

#### 简述php的垃圾收集机制。
> php中的变量存储在变量容器zval中，zval中除了存储变量类型和值外，还有is_ref和refcount字段。refcount表示指向变量的元素个数，is_ref表示变量是否有别名。如果refcount为0时，就回收该变量容器。如果一个zval的refcount减1之后大于0，它就会进入垃圾缓冲区。当缓冲区达到最大值后，回收算法会循环遍历zval，判断其是否为垃圾，并进行释放处理。

#### echo、print_r、print、var_dump区别
- echo：语句结构；
- print：是函数，有返回值
- print_r：能打印数组，对象
- var_dump:能打印对象数组，并且带数据类型

#### 写出smarty模板的特点
> 速度快，编译型，缓存技术，插件机制，强大的表现逻辑

#### 如何把一个GB2312格式的字符串装换成UTF-8格式？

```
iconv('GB2312','UTF-8','IT技能学习');
```

#### 如果需要原样输出用户输入的内容，在数据入库前，要用哪个函数处理？

> htmlspecialchars或者htmlentities

#### 什么是事务？及其特性？
> 事务：是一系列的数据库操作，是数据库应用的基本逻辑单位。

**事务特性：**
1. 原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。
2. 一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态
3. 隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
4. 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

> **或者这样理解**：
> 事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。

#### 什么是锁？
> 数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

> 加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

> 基本锁类型：锁包括行级锁和表级锁

#### 索引的作用？和它的优点缺点是什么？
> 索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。

#### 如何通俗地理解三个范式？

- 第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；
- 第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；
- 第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。

#### 主键、外键和索引的区别？

> 定义：
> 主键--唯一标识一条记录，不能有重复的，不允许为空
> 外键--表的外键是另一表的主键, 外键可以有重复的, 可以是空值
>索引--该字段没有重复值，但可以有一个空值

> 作用：
> 主键--用来保证数据完整性
> 外键--用来和其他表建立联系用的
> 索引--是提高查询排序的速度

> 个数：
> 主键--主键只能有一个
> 外键--一个表可以有多个外键
> 索引--一个表可以有多个唯一索引

#### 简述 private、 protected、 public修饰符的访问权限。

- private : 私有成员, 在类的内部才可以访问。
- protected : 保护成员，该类内部和继承类中可以访问。
- public : 公共成员，完全公开，没有访问限制。

#### 堆和栈的区别？
- 堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小；
- 栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义。

#### 常用的魔术方法有哪些？举例说明

> php规定以两个下划线（__）开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。

- __construct() 实例化类时自动调用。
- __destruct() 类对象使用结束时自动调用。
- __set() 在给未定义的属性赋值的时候调用。
- __get() 调用未定义的属性时候调用。
- __isset() 使用isset()或empty()函数时候会调用。
- __unset() 使用unset()时候会调用。
- __sleep() 使用serialize序列化时候调用。
- __wakeup() 使用unserialize反序列化的时候调用。
- __call() 调用一个不存在的方法的时候调用。
- __callStatic()调用一个不存在的静态方法是调用。
- __toString() 把对象转换成字符串的时候会调用。比如 echo。
- __invoke() 当尝试把对象当方法调用时调用。
- __set_state() 当使用var_export()函数时候调用。接受一个数组参数。
- __clone() 当使用clone复制一个对象时候调用。

#### $this和self、parent这三个关键词分别代表什么？在哪些场合下使用？

> $this 当前对象
> self 当前类
> parent 当前类的父类

> $this在当前类中使用,使用->调用属性和方法
> self也在当前类中使用，不过需要使用::调用
> parent在类中使用

#### 作用域操作符::如何使用？都在哪些场合下使用？
- 调用类常量
- 调用静态方法

#### __autoload()方法的工作原理是什么？
> 使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。
> 当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行__autoload()函数。
> 这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后
> 就执行include或者require来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。
> 使用自动载入的魔术函数可以不必要写很多个include或者require函数。

#### 简述高并发网站解决方案。
- 前端优化（CND加速、建立独立图片服务器）
- 服务端优化（页面静态化、并发处理[异步|多线程]、队列处理）
- 数据库优化（数据库缓存[Memcachaed|Redis]、读写分离、分库分表、分区）
- Web服务器优化（负载均衡、反向代理）

#### Mysql的存储引擎,myisam和innodb的区别。
- MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持；
- MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快；
- InnoDB不支持FULLTEXT类型的索引；
- InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可；
- 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引；
- DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除；
- LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用；
- MyISAM支持表锁，InnoDB支持行锁。

> MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。

> InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。

